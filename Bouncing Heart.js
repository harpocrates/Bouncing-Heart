// Generated by CoffeeScript 1.8.0
'use strict';
var Body, Polygon, Vector, addPosition, animate, body, c, canvas, caught_object, clearCanvas, clearing_events, context, drawDot, drawLine, drawing_events, id, launching_events, path, pen_down, setEvents, _ref, _ref1;

Vector = (function() {
  function Vector(x, y, z) {
    this.x = x != null ? x : 0;
    this.y = y != null ? y : 0;
    this.z = z != null ? z : 0;
  }

  Vector.prototype.add = function(v) {
    return new Vector(this.x + v.x, this.y + v.y, this.z + v.z);
  };

  Vector.prototype.multiply = function(s) {
    return new Vector(this.x * s, this.y * s, this.z * s);
  };

  Vector.prototype.subtract = function(v) {
    return new Vector(this.x - v.x, this.y - v.y, this.z - v.z);
  };

  Vector.prototype.negative = function(v) {
    return new Vector(-this.x, -this.y, -this.z);
  };

  Vector.prototype.norm = function(v) {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  };

  Vector.prototype.dot = function(v) {
    return this.x * v.x + this.y * v.y + this.z * v.z;
  };

  Vector.prototype.cross = function(v) {
    return new Vector(this.y * v.z - this.z * v.y, this.z * v.x - this.x * v.z, this.x * v.y - this.y * v.x);
  };

  Vector.prototype.rotate = function(a) {
    return new Vector(this.x * Math.cos(a) - this.y * Math.sin(a), this.y * Math.cos(a) + this.x * Math.sin(a));
  };

  return Vector;

})();

Polygon = (function() {
  function Polygon(vertices) {
    this.vertices = vertices;
  }

  Polygon.prototype.translate = function(v) {
    return new Polygon(this.vertices.map(function(w) {
      return w.add(v);
    }));
  };

  Polygon.prototype.getCentroid = function() {
    var A2, C, f, i, j, p1, p2, _ref, _ref1, _ref2;
    A2 = 0;
    C = new Vector();
    _ref = [0, this.vertices.length - 1], i = _ref[0], j = _ref[1];
    while (i < this.vertices.length) {
      _ref1 = [this.vertices[i], this.vertices[j]], p1 = _ref1[0], p2 = _ref1[1];
      _ref2 = [p1.x * p2.y - p2.x * p1.y, i++], f = _ref2[0], j = _ref2[1];
      A2 += f;
      C.x += (p1.x + p2.x) * f;
      C.y += (p1.y + p2.y) * f;
    }
    return C.multiply(1 / (A2 * 3));
  };

  Polygon.prototype.getMoment = function() {
    var I, f, i, j, p1, p2, _ref, _ref1, _ref2;
    I = 0;
    _ref = [0, this.vertices.length - 1], i = _ref[0], j = _ref[1];
    while (i < this.vertices.length) {
      _ref1 = [this.vertices[i], this.vertices[j]], p1 = _ref1[0], p2 = _ref1[1];
      _ref2 = [p1.x * p2.y - p2.x * p1.y, i++], f = _ref2[0], j = _ref2[1];
      I += (p1.x * p1.x + p1.y * p1.y + p1.x * p2.x + p1.y * p2.y + p2.x * p2.x + p2.y * p2.y) * f;
    }
    return I;
  };

  Polygon.prototype.getArea = function() {
    var A2, i, j, l, p1, p2, _ref, _ref1, _ref2;
    _ref = [0, this.vertices.length], A2 = _ref[0], l = _ref[1];
    _ref1 = [0, this.vertices.length - 1], i = _ref1[0], j = _ref1[1];
    while (i < this.vertices.length) {
      _ref2 = [this.vertices[i], this.vertices[j]], p1 = _ref2[0], p2 = _ref2[1];
      A2 += p1.x * p2.y - p2.x * p1.y;
      j = i++;
    }
    return A2 / 2;
  };

  Polygon.prototype.contains = function(point) {
    var i, inside, p1, p2, xints, _i, _ref, _ref1;
    inside = false;
    p1 = this.vertices[0];
    for (i = _i = 1, _ref = this.vertices.length; 1 <= _ref ? _i < _ref : _i > _ref; i = 1 <= _ref ? ++_i : --_i) {
      p2 = this.vertices[i];
      if ((Math.min(p1.y, p2.y) < (_ref1 = point.y) && _ref1 <= Math.max(p1.y, p2.y)) && point.x <= Math.max(p1.x, p2.x)) {
        if (p1.y !== p2.y) {
          xints = (point.y - p1.y) * (p2.x - p1.x) / (p2.y - p1.y) + p1.x;
        }
        if (p1.x === p2.x || point.x <= xints) {
          inside = !inside;
        }
      }
      p1 = p2;
    }
    return inside;
  };

  Polygon.prototype.draw = function(fill) {
    var c, i, v, _i, _len, _ref, _ref1;
    if (fill == null) {
      fill = false;
    }
    c = context;
    c.save();
    _ref = ["red", "red", "round", 2], c.strokeStyle = _ref[0], c.fillStyle = _ref[1], c.lineJoin = _ref[2], c.lineWidth = _ref[3];
    c.beginPath();
    _ref1 = this.vertices;
    for (i = _i = 0, _len = _ref1.length; _i < _len; i = ++_i) {
      v = _ref1[i];
      c[i === 0 ? 'moveTo' : 'lineTo'](v.x, v.y);
    }
    c.closePath();
    if (fill) {
      c.fill();
    } else {
      c.stroke();
    }
    return c.restore();
  };

  return Polygon;

})();

Body = (function() {
  function Body(polygon, pos, vel, ang, ang_v) {
    var A, I, c, _ref;
    this.polygon = polygon;
    this.pos = pos;
    this.vel = vel;
    this.ang = ang;
    this.ang_v = ang_v;
    if (!(this.polygon instanceof Polygon)) {
      this.polygon = new Polygon(this.polygon);
    }
    c = this.polygon.getCentroid();
    this.polygon = this.polygon.translate(c.negative());
    _ref = [this.polygon.getArea(), this.polygon.getMoment()], A = _ref[0], I = _ref[1];
    this.mass = Math.abs(A);
    this.moment = Math.abs(I / 3);
    this.pos = this.pos || c;
    this.vel = this.vel || 0;
    this.ang = this.ang || 0;
    this.ang_v = this.ang_v || 0;
  }

  Body.prototype.draw = function() {
    context.save();
    context.translate(this.pos.x, this.pos.y);
    context.rotate(this.ang);
    this.polygon.draw(true);
    return context.restore();
  };

  Body.prototype.vertices = function() {
    return new Polygon(this.polygon.vertices.map((function(_this) {
      return function(v) {
        return v.rotate(_this.ang).add(_this.pos);
      };
    })(this)));
  };

  return Body;

})();

canvas = document.getElementById("canvas");

context = canvas.getContext("2d");

setEvents = (function() {
  var listeners;
  listeners = {};
  return function(event_object) {
    var listener, type, _results;
    _results = [];
    for (type in event_object) {
      listener = event_object[type];
      if (listeners[type] != null) {
        canvas.removeEventListener(type, listeners[type]);
      }
      canvas.addEventListener(type, listener);
      _results.push(listeners[type] = listener);
    }
    return _results;
  };
})();

clearCanvas = function() {
  return context.clearRect(0, 0, context.canvas.width, context.canvas.height);
};

drawDot = function(x, y, fill) {
  context.save();
  context.beginPath();
  context.arc(x, y, 3, 0, Math.PI * 2, false);
  context.fillStyle = fill;
  context.fill();
  context.closePath();
  return context.restore();
};

drawLine = function(x1, y1, x2, y2, fill) {
  context.save();
  context.beginPath();
  context.moveTo(x1, y1);
  context.lineTo(x2, y2);
  context.strokeStyle = fill;
  context.stroke();
  context.closePath();
  return context.restore();
};

_ref = [false, new Polygon([]), void 0], pen_down = _ref[0], path = _ref[1], body = _ref[2];

addPosition = function(x, y) {
  return path.vertices.push(new Vector(x, y));
};

drawing_events = {
  mousedown: function(e) {
    pen_down = true;
    addPosition(e.pageX - this.offsetLeft, e.pageY - this.offsetTop);
    clearCanvas();
    return path.draw();
  },
  mousemove: function(e) {
    if (pen_down) {
      addPosition(e.pageX - this.offsetLeft, e.pageY - this.offsetTop);
      clearCanvas();
      return path.draw();
    }
  },
  mouseup: function(e) {
    var _ref1;
    body = new Body(path.vertices.concat(path.vertices[0]));
    clearCanvas();
    body.draw();
    _ref1 = [false, []], pen_down = _ref1[0], path.vertices = _ref1[1];
    return setEvents(launching_events);
  },
  mouseleave: function(e) {
    var _ref1;
    if (pen_down) {
      _ref1 = [false, []], pen_down = _ref1[0], path.vertices = _ref1[1];
      return clearCanvas();
    }
  }
};

id = void 0;

_ref1 = [void 0, false], c = _ref1[0], caught_object = _ref1[1];

launching_events = {
  mousedown: function(e) {
    var vertices, x, y, _ref2, _ref3;
    _ref2 = [e.pageX - this.offsetLeft, e.pageY - this.offsetTop], x = _ref2[0], y = _ref2[1];
    vertices = body.vertices();
    if (vertices.contains(new Vector(x, y))) {
      body.vel = new Vector();
      body.ang_v = 0;
      _ref3 = [vertices.getCentroid(), true], c = _ref3[0], caught_object = _ref3[1];
      return drawDot(c.x, c.y);
    }
  },
  mousemove: function(e) {
    if (caught_object) {
      clearCanvas();
      body.draw();
      drawDot(c.x, c.y, "black");
      drawLine(c.x, c.y, e.pageX - this.offsetLeft, e.pageY - this.offsetTop, "black");
      return drawDot(e.pageX - this.offsetLeft, e.pageY - this.offsetTop, "black");
    }
  },
  mouseup: function(e) {
    if (!caught_object) {
      return;
    }
    body.vel = new Vector(e.pageX - this.offsetLeft - c.x, e.pageY - this.offsetTop - c.y).multiply(1 / 7);
    caught_object = false;
    if (id == null) {
      return id = setInterval((function() {
        return animate(body);
      }), 1000 / 60);
    }
  },
  mouseleave: function(e) {}
};

animate = function(body) {
  var H, W, border_function, e, extrema, g, i, intersection_points, j, n, r_ap, transformed_vertices, v1, v2, v_ap, _, _i, _len, _ref10, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
  if (caught_object) {
    return;
  }
  _ref2 = [new Vector(0, 0.2), 0.7], g = _ref2[0], e = _ref2[1];
  _ref3 = [canvas.height, canvas.width], H = _ref3[0], W = _ref3[1];
  clearCanvas();
  body.draw();
  _ref4 = [body.pos.add(body.vel), body.vel.add(g), body.ang + body.ang_v], body.pos = _ref4[0], body.vel = _ref4[1], body.ang = _ref4[2];
  transformed_vertices = body.vertices().vertices;
  n = new Vector();
  _ref5 = transformed_vertices.slice(0, -1);
  for (i = _i = 0, _len = _ref5.length; _i < _len; i = ++_i) {
    _ = _ref5[i];
    if (n.norm() !== 0) {
      break;
    }
    _ref6 = transformed_vertices.slice(i, +(i + 1) + 1 || 9e9), v1 = _ref6[0], v2 = _ref6[1];
    switch (false) {
      case !((v1.x - W) * (v2.x - W) <= 0):
        _ref7 = [
          new Vector(-1, 0, 0), function(v) {
            return v.x - W;
          }
        ], n = _ref7[0], border_function = _ref7[1];
        break;
      case !(v1.x * v2.x <= 0):
        _ref8 = [
          new Vector(1, 0, 0), function(v) {
            return -v.x;
          }
        ], n = _ref8[0], border_function = _ref8[1];
        break;
      case !((v1.y - H) * (v2.y - H) <= 0):
        _ref9 = [
          new Vector(0, -1, 0), function(v) {
            return v.y - H;
          }
        ], n = _ref9[0], border_function = _ref9[1];
        break;
      case !(v1.y * v2.y <= 0):
        _ref10 = [
          new Vector(0, 1, 0), function(v) {
            return -v.y;
          }
        ], n = _ref10[0], border_function = _ref10[1];
    }
  }
  if (n.norm() !== 0) {
    extrema = Math.max.apply(this, transformed_vertices.map(border_function));
    body.pos = body.pos.add(n.multiply(extrema));
    intersection_points = transformed_vertices.filter(function(v) {
      return border_function(v) === extrema;
    });
    c = intersection_points.reduce(function(acc, point) {
      return acc.add(point);
    }).multiply(1 / intersection_points.length);
    r_ap = c.subtract(body.pos);
    v_ap = body.vel.add((new Vector(0, 0, body.ang_v)).cross(r_ap));
    j = -(1 + e) * v_ap.dot(n) / (1 / body.mass + Math.pow(r_ap.cross(n).norm(), 2) / body.moment);
    body.ang_v = body.ang_v + r_ap.cross(n.multiply(j)).z / body.moment;
    return body.vel = body.vel.add(n.multiply(j / body.mass)).multiply(0.9);
  }
};

clearing_events = {
  mousedown: function(e) {},
  mousemove: function(e) {},
  mouseup: function(e) {},
  mouseleave: function(e) {}
};

setEvents(drawing_events);
